// AEhkRigidBodyPrimitiveTemplate.mel

source AEmpRigidBodyPrimitiveTemplate;

global proc AEhkRigidBodyPrimitiveTemplate(string $nodeName)
{
	editorTemplate -beginScrollLayout;

// Re-Implement this panel

		editorTemplate -beginLayout "Geometry Settings" -collapse 0;
			editorTemplate -beginNoOptimize;

				editorTemplate -label "Havok2 Shape Type" -addControl "shapeType" "AEhkRBP_updateGeometry";
				editorTemplate -addControl "tessellationFactor";						

//				editorTemplate -callCustom	"AEhkRBPConvexityButtonNew" "AEhkRBPConvexityButtonReplace" "hkDummy";
			editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		editorTemplate -beginLayout "Simulation Settings" -collapse 0;
			editorTemplate -beginNoOptimize;
				editorTemplate -addControl	"disabled" "AEhkCheckIfCompound";
			editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		// finalize the editor by activating/deactivating controls based on current values
		editorTemplate -callCustom "AEhkRBPRefresh" "AEhkRBPRefresh" "hkDummy";

		// Monolith Attributes
		AEmpRigidBodyPrimitiveAttributes $nodeName;

		editorTemplate -addExtraControls;

	editorTemplate -endScrollLayout;

	editorTemplate -suppress "caching";
	editorTemplate -suppress "nodeState";
	editorTemplate -suppress "disableCollisions";
	editorTemplate -suppress "mass";

	editorTemplate -suppress "convexProxyName";
	editorTemplate -suppress "concaveProxyName";
	editorTemplate -suppress "inGeometry";
	editorTemplate -suppress "inRigidBody";
	editorTemplate -suppress "collisionGroup";
	editorTemplate -suppress "convexOptimization";
	editorTemplate -suppress "concaveOptimization";
	
	editorTemplate -suppress "geometryType";
	editorTemplate -suppress "convexGeometry";
	editorTemplate -suppress "concaveGeometry";
	
}

global proc AEhkRBPConvexityButtonNew(string $attr)
{
	setUITemplate -pst attributeEditorTemplate;

	rowLayout -nc 2;
		text -l "";
		button -l "Test Convexity..." "hkRBPConvexityButton";
	setParent ..;

	setUITemplate -ppt;

	AEhkRBPConvexityButtonReplace $attr;
}

global proc AEhkRBPConvexityButtonReplace(string $attr)
{
	button -e -en 0 -c "hkTestConvexity" "hkRBPConvexityButton";
}

// Convex

global proc AEhkRBPConvexProxyCtrlNew(string $attr)
{
	setUITemplate -pst attributeEditorTemplate;

	attrNavigationControlGrp -at $attr -l "Convex Proxy Name" "hkRBPConvexProxyGrp";

	setUITemplate -ppt;

	AEhkRBPConvexProxyCtrlReplace $attr;
}

global proc AEhkRBPConvexProxyCtrlReplace(string $attr)
{
	attrNavigationControlGrp -e -en 0 "hkRBPConvexProxyGrp";
}

// Concave

global proc AEhkRBPConcaveProxyCtrlNew(string $attr)
{
	setUITemplate -pst attributeEditorTemplate;

	attrNavigationControlGrp -at $attr -l "Concave Proxy Name" "hkRBPConcaveProxyGrp";

	setUITemplate -ppt;

	AEhkRBPConcaveProxyCtrlReplace $attr;
}

global proc AEhkRBPConcaveProxyCtrlReplace(string $attr)
{
	attrNavigationControlGrp -e -en 0 "hkRBPConcaveProxyGrp";
}




global proc AEhkRBP_updateGeometry(string $node)
{
	string $tokens[];
	int $n = `tokenize $node "." $tokens`;

	// Check if the shapeType attribute is still set to '1001' (invalid)
	int $shapeType = `getAttr ($tokens[0] + ".shapeType")`;
	
	if( $shapeType == 1001 )
	{
		int $geometryType = `getAttr ($tokens[0] + ".geometryType")`;
		
		if( $geometryType )
		{
			// concave mesh geometry
			setAttr ($tokens[0] + ".shapeType") 4;
		}
		
		else
		{
			// convex geometry
			int $convexType = `getAttr ($tokens[0] + ".convexGeometry")`;
			
			switch( $convexType )
			{
				case 0:
				{
					// Bounding Box
					setAttr ($tokens[0] + ".shapeType") 0;
					break;
				}

				case 1:
				{
					// Bounding Sphere
					setAttr ($tokens[0] + ".shapeType") 1;
					break;
				}

				default:
				{
					// Convex Mesh Hull
					setAttr ($tokens[0] + ".shapeType") 3;
					break;
				}
				
			}
			
		}

	}

	// update the mass control (dimming) for the entity depending
	// on whether the geometry is concave or convex.
	
	$shapeType = `getAttr ($tokens[0] + ".shapeType")`;
	string $entityName[] = `listConnections -s false -d true -t hkRigidBodyEntity $tokens[0]`;
	

	if( $shapeType == 4 )
	{
		// dim the control in the Attribute Editor
		editorTemplate -dc $entityName[0] assignedMass true;
		
		// remove the assignedMass attribute from the outliner
		setAttr -e -keyable false ($entityName[0] + ".assignedMass");
	}
	
	else
	{
		// undim the control in the Attribute Editor
		editorTemplate -dc $entityName[0] assignedMass false;
		
		// add the assignedMass attribute to the outliner
		setAttr -e -keyable true ($entityName[0] + ".assignedMass");		
	}
		
}


// Refresh function
global proc AEhkRBPRefresh(string $node)
{
	string $tokens[];
	int $n = `tokenize $node "." $tokens`;

	string $geometries[] = `listConnections -d off -s on -shapes true -type "nurbsSurface" ($tokens[0] + ".inGeometry")`;
	switch (`size($geometries)`)
	{
	case 1:
		editorTemplate -dimControl $tokens[0] "tessellationFactor" 0;
		break;
	default:
		editorTemplate -dimControl $tokens[0] "tessellationFactor" 1;
		break;
	};

	int $type = `getAttr ($tokens[0] + ".geometryType")`;
	switch ($type)
	{
		
	// Convex geometry	
	case 0:
		editorTemplate -dimControl $tokens[0] "convexGeometry" 0;
		editorTemplate -dimControl $tokens[0] "concaveGeometry" 1;
		break;
		
	// Concave geometry
	case 1:
		editorTemplate -dimControl $tokens[0] "convexGeometry" 1;
		editorTemplate -dimControl $tokens[0] "concaveGeometry" 0;
		break;
		
	};

	editorTemplate -dimControl $tokens[0] "convexOptimization" 1;
	editorTemplate -dimControl $tokens[0] "concaveOptimization" 1;
}

global proc AEhkCheckIfCompound( string $node )
{
	string $tokens[];
	int $n = `tokenize $node "." $tokens`;
	
	// get the parent entity and check if it has multiple primitives
	string $entity[] = `listConnections -type hkRigidBodyEntity $tokens[0]`;
	string $allPrims[] = `listConnections -type hkRigidBodyPrimitive $entity[0]`;
	
	if( `size($allPrims)` == 1 )
	{
		// single primitive		
		editorTemplate -dimControl $tokens[0] "disabled" 1;
	}
	
}
